function [EEG,com]=pop_marks_merge_labels(EEG,infotype,labels,varargin)

com = ''; % this initialization ensure that the function will return something
          % if the user press the cancel button            


% display help if not enough arguments
% ------------------------------------
if nargin < 1
	help pop_marks_merge_labels;
	return;
end;	

try
    options = varargin;
    for index = 1:length(options)
        if iscell(options{index}) && ~iscell(options{index}{1}), options{index} = { options{index} }; end;
    end;
    if ~isempty( varargin ), g=struct(options{:});
    else g= []; end;
catch
    disp('marks_merge_labels() error: calling convention {''key'', value, ... } error'); return;
end;

try g.target_label; catch, g.target_label='manual';end


infotype_cell={'time_info','chan_info'};
if ~isempty(EEG.icaweights);
    infotype_cell={infotype_cell{:},'comp_info'};
end
if exist('infotype');
    infotype_ind=find(strcmp(infotype,infotype_cell));
else
    infotype='time_info';
    infotype_ind=1;
end

% pop up window
% -------------
if nargin < 3
    
    results=inputgui( ...
        {[1] [3 3] [1] [5 1] 1 [5 1]}, ...
        {...
        {'Style', 'text', 'string',blanks(140)}, ...
        ...%1
        {'Style', 'text', 'string', 'Info type to edit'}, ...
        ... %2
        {'Style', 'popup', 'string', infotype_cell, 'value',infotype_ind,'tag', 'pop_it'...
        'callback', ['switch get(findobj(gcbf, ''tag'', ''pop_it''), ''value'');' ...
        '    case 1;' ...
        '        tmp_label = {EEG.marks.time_info.label};' ...
        '        set(findobj(gcbf, ''tag'', ''but_fl''), ''callback'',' ...
        '            [''[flaglabel_ind,flaglabel_str,flaglabel_cell]=pop_chansel({EEG.marks.time_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_fl''''), ''''string'''', vararg2str(flaglabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_fl''), ''string'', '''');' ...
        '        set(findobj(gcbf, ''tag'', ''but_tl''), ''callback'',' ...
        '            [''[targlabel_ind,targlabel_str,targlabel_cell]=pop_chansel({EEG.marks.time_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_tl''''), ''''string'''', vararg2str(targlabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_tl''), ''string'', '''');' ...
        '    case 2;' ...
        '        tmp_label = {EEG.marks.chan_info.label};' ...
        '        set(findobj(gcbf, ''tag'', ''but_fl''), ''callback'',' ...
        '            [''[flaglabel_ind,flaglabel_str,flaglabel_cell]=pop_chansel({EEG.marks.chan_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_fl''''), ''''string'''', vararg2str(flaglabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_fl''), ''string'', '''');' ...
        '        set(findobj(gcbf, ''tag'', ''but_tl''), ''callback'',' ...
        '            [''[targlabel_ind,targlabel_str,targlabel_cell]=pop_chansel({EEG.marks.chan_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_tl''''), ''''string'''', vararg2str(targlabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_tl''), ''string'', '''');' ...
        '    case 3;' ...
        '        tmp_label = {EEG.marks.comp_info.label};' ...
        '        set(findobj(gcbf, ''tag'', ''but_fl''), ''callback'',' ...
        '            [''[flaglabel_ind,flaglabel_str,flaglabel_cell]=pop_chansel({EEG.marks.comp_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_fl''''), ''''string'''', vararg2str(flaglabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_fl''), ''string'', '''');' ...
        '        set(findobj(gcbf, ''tag'', ''but_tl''), ''callback'',' ...
        '            [''[targlabel_ind,targlabel_str,targlabel_cell]=pop_chansel({EEG.marks.comp_info.label});' ...
        '             set(findobj(gcbf, ''''tag'''', ''''edt_tl''''), ''''string'''', vararg2str(targlabel_cell))'']);' ...
        '        set(findobj(gcbf, ''tag'', ''edt_tl''), ''string'', '''');' ...
        '    end;']}, ...
        ... %3
        {'Style', 'text', 'string', 'marks labels to merge'},...
        ... %4
        {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ...
        ... %5
        {'Style', 'pushbutton', 'string', '...','tag','but_fl', ...
        'callback', ['[flaglabel_ind,flaglabel_str,flaglabel_cell]=pop_chansel({EEG.marks.time_info.label});' ...
        'set(findobj(gcbf, ''tag'', ''edt_fl''), ''string'', vararg2str(flaglabel_cell))']}, ...
        ...
        {'Style', 'text', 'string', 'target marks label to merge into'},...
        ... %4
        {'Style', 'edit', 'string', '', 'tag', 'edt_tl'}, ...
        ... %5
        {'Style', 'pushbutton', 'string', '...','tag','but_tl', ...
        'callback', ['[targlabel_ind,targlabel_str,targlabel_cell]=pop_chansel({EEG.marks.time_info.label});' ...
        'set(findobj(gcbf, ''tag'', ''edt_tl''), ''string'', vararg2str(targlabel_cell))']}, ...
        }, ...
        'pophelp(''pop_mark_merge_label'');', 'merge marks labels into target label -- pop_mark_flag_gap()' ...
        );
    
    if isempty(results);return;end
    
    infotype_ind  	 = results{1};
    infotype=infotype_cell{infotype_ind};
    labels     	     = eval(['{',results{2},'};']); 
    g.target_label   = eval(['{',results{3},'};']); 
%    newlabel  = results{3};
%    newcolor      = results{4};
end

if isempty(labels)||isempty(g.target_label)
    disp('Both "labels" and "target_label" inputs must be specified... Doing nothing...');
    return
end

if iscell(g.target_label)
    g.target_label=g.target_label{1};
end

switch infotype
    case 'time_info'
       ind=find(strcmp(g.target_label,{EEG.marks.time_info.label})); 
       [labels_inds]=marks_label2index(EEG.marks.time_info,labels,'indexes');
       if length(size(EEG.marks.time_info(ind).flags))==2;
           EEG.marks.time_info(ind).flags(labels_inds)=1;
       elseif length(size(EEG.marks.time_info(ind).flags))==3;
           EEG.marks.time_info(ind).flags(:,:,labels_inds)=1;
       end
    case 'chan_info'
       ind=find(strcmp(g.target_label,{EEG.marks.chan_info.label})); 
       [labels_inds]=marks_label2index(EEG.marks.chan_info,labels,'indexes');
       EEG.marks.chan_info(ind).flags(labels_inds)=1;
    case 'comp_info'
        ind=find(strcmp(g.target_label,{EEG.marks.comp_info.label}));
        [labels_inds]=marks_label2index(EEG.marks.comp_info,labels,'indexes');
        if isempty(EEG.marks.comp_info(ind).flags);
            notind = setdiff([1:length(EEG.marks.comp_info)],ind) ;  
            try
            EEG.marks.comp_info(ind).flags=zeros(size(EEG.marks.comp_info(notind(1)).flags));
            catch
                disp('You can not overwite a marks array with an empty array!')
            end
        end
       EEG.marks.comp_info(ind).flags(labels_inds)=1;
end
